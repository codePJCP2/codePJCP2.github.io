# 数组-2 2024/09/23

> 今日题目：[5. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/) [6. 螺旋矩阵 Ⅱ](https://leetcode.cn/problems/spiral-matrix-ii/description/)
>

## 长度最小的子数组
### 题目说明
<font style="color:rgb(44, 62, 80);">给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</font>

### 常规解法
```python
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        l = len(nums)
        min_len = float('inf')

        for i in range(l):
            cur_sum = 0
            for j in range(i, l):
                cur_sum += nums[j]
                if cur_sum >= s:
                    min_len = min(min_len, j - i + 1)
                    break

        return min_len if min_len != float('inf') else 0
```

### 优化解法(滑窗)
```java
public int minSubArrayLen(int target, int[] nums) {
    int n = nums.length;
    int left = 0, sum = 0;
    int ans = n + 1;
    // 先尝试扩张窗口，等到区间内总和大于等于target时再收缩
    // 处理之后的长度相当于当前右端点的最小长度
    for(int right = 0; right < n; right++) {
        // 扩张窗口
        sum += nums[right];
        // 收缩窗口
        while(sum >= target) {
            ans = Math.min(right - left + 1, ans);
            sum -= nums[left];
            left++;
        }
    }

    return (ans == n + 1? 0 : ans);
}
```

### 相关题目
- [x] [<font style="color:rgb(44, 62, 80);">904.水果成篮</font>](https://leetcode.cn/problems/fruit-into-baskets/)<font style="color:rgb(44, 62, 80);">(滑窗)</font>
- [x] [<font style="color:rgb(44, 62, 80);">76.最小覆盖子串</font>](https://leetcode.cn/problems/minimum-window-substring/)<font style="color:rgb(44, 62, 80);">(</font>**<font style="color:rgb(44, 62, 80);">最短型</font>**<font style="color:rgb(44, 62, 80);">滑窗)</font>

## 水果成篮
### 滑窗思路解析
这题的意思实际上是让我们求**只出现****<u>两种</u>****字符的最大子区间长度**。

那么可以用一个变量来存储当前区间内存在的字符种类数量，并且使用哈希表来存储各字符在当前窗口内出现的次数。

所以收缩窗口的条件为：`kind > 2`

```java
class Solution {
    public int totalFruit(int[] fruits) {
        // 求只出现两种字符的最大子区间长度
        // 使用哈希表来维护当前区间出现的字符情况
        int n = fruits.length;
        int[] counts = new int[n];
        int ans = 0, kind = 0;
        int left = 0;
        for (int right = 0; right < n; right++) {
            if (counts[fruits[right]] == 0) {
                // 统计当前持有的水果总类
                kind++;
            }
            // 扩张窗口
            counts[fruits[right]]++;
            // 种类大于等于3时，触发窗口收缩
            while (kind > 2) {
                counts[fruits[left]]--;
                if (counts[fruits[left]] == 0) {
                    kind--;
                }
                left++;
            }

            // 统计长度
            ans = Math.max(right - left + 1, ans);
        }
        return ans;
    }
}
```

## 最小覆盖子串
> 不愧是困难题，真的有点复杂
>

### 题目说明
给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

+ 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须**不少于** `t` 中该字符数量。
+ 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

### 概念：字符串涵盖
对于这道题目来说，字符串涵盖这个概念实际上就是题目的注意点 1。

例如示例一中 `s` 的子串 `BANC` 中每个字符出现的频率都大于等于 `t` 串中的频率，这就叫**字符串涵盖**。

### 基本思路分析
在了解了[涵盖](#F7jZz)的概念之后，我们可以把题目要求转换为如下的描述：

> 给定两个字符串 `s` `t` ，返回 `s` 中涵盖字符串 `t` 的**最小**子串。
>

也许可以尝试用**最短型滑窗**的思路来解决这道问题。

可以确定**收缩**条件：当前窗口内的字符串涵盖字符串 `t` 

> Q：如何表示涵盖条件呢？
>

在字符串涵盖这一概念的定义中， 其实已经说明了一个最直接的判断方法：

判断字符串中的**每个字符出现频率**都**大于等于**被涵盖字符串中的频率。

字符出现的频率可以用哈希表记录，在扩张/收缩时进行修改记录。

由此，我们可以得到解题的基本思路：

1. 初始化
2. 统计 `t` 字符串中各字符出现的频率
3. 枚举右端点，尝试进行窗口扩张
4. 若满足涵盖条件，则尝试进行窗口收缩，并更新答案
5. 返回答案对应窗口内的字符串

### Show me the code!
```java
class Solution {
    public String minWindow(String S, String t) {
        char[] s = S.toCharArray();
        int m = s.length;
        int ansLeft = -1;
        int ansRight = m;
        int left = 0;
        int[] cntS = new int[128]; // s 子串字母的出现次数
        int[] cntT = new int[128]; // t 中字母的出现次数
        for (char c : t.toCharArray()) {
            cntT[c]++;
        }
        for (int right = 0; right < m; right++) { // 移动子串右端点
            cntS[s[right]]++; // 右端点字母移入子串
            while (isCovered(cntS, cntT)) { // 涵盖
                if (right - left < ansRight - ansLeft) { // 找到更短的子串
                    ansLeft = left; // 记录此时的左右端点
                    ansRight = right;
                }
                cntS[s[left++]]--; // 左端点字母移出子串
            }
        }
        return ansLeft < 0 ? "" : S.substring(ansLeft, ansRight + 1);
    }

    /**
     * 判断是否涵盖
     */
    private boolean isCovered(int[] cntS, int[] cntT) {
        for (int i = 'A'; i <= 'Z'; i++) {
            if (cntS[i] < cntT[i]) {
                return false;
            }
        }
        for (int i = 'a'; i <= 'z'; i++) {
            if (cntS[i] < cntT[i]) {
                return false;
            }
        }
        return true;
    }
}
```

## 滑窗总结
滑窗的一般思路如下：

1. 初始化状态(根据枚举条件来，例如枚左移右等)
2. 让滑窗**扩张**(移动端点)
3. 根据限制条件来**收缩**滑窗
4. 在移动过程中(视具体情况而定)更新答案



> 更新: 2024-09-23 12:18:27  
> 原文: <https://www.yuque.com/yuqueyonghukaqxkk/self_learning_route/xr4nuqrosfegymfd>